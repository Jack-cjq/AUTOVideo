# 中心管理平台实现方案

## 项目概述

本文档描述了一个轻量级的中心管理平台实现方案，用于管理多个设备上的抖音自动化功能。平台通过HTTP API提供统一的接口，支持远程触发登录、视频上传和对话功能。

## 系统架构

### 整体架构

```
┌─────────────────┐
│  中心管理平台    │  (Flask API Server)
│  (API Server)   │
└────────┬────────┘
         │ HTTP API
         │
    ┌────┴────┬──────────┬──────────┐
    │         │          │          │
┌───▼───┐ ┌──▼───┐  ┌───▼───┐  ┌───▼───┐
│设备1  │ │设备2 │  │设备3 │  │设备N │
│(Agent)│ │(Agent)│  │(Agent)│  │(Agent)│
└───────┘ └──────┘  └───────┘  └───────┘
```

### 技术选型

- **后端框架**: Flask (项目已包含，无需额外依赖)
- **数据存储**: SQLite数据库 (轻量级，无需额外服务)
- **通信协议**: HTTP RESTful API
- **数据格式**: JSON

## 核心功能模块

### 1. 设备管理模块

#### 功能描述
- 设备注册：新设备首次连接时注册到系统
- 设备状态：记录设备在线状态、最后心跳时间
- 设备信息：设备ID、设备名称、IP地址等

#### 数据模型
```python
设备表 (devices)
- id: 主键，自增
- device_id: 设备唯一标识（UUID或自定义）
- device_name: 设备名称
- ip_address: 设备IP地址
- status: 在线状态 (online/offline)
- last_heartbeat: 最后心跳时间
- created_at: 创建时间
- updated_at: 更新时间
```

#### API接口
- `POST /api/devices/register` - 设备注册
- `GET /api/devices` - 获取设备列表
- `GET /api/devices/{device_id}` - 获取设备详情
- `POST /api/devices/{device_id}/heartbeat` - 设备心跳

### 2. 账号管理模块

#### 功能描述
- 账号绑定：将抖音账号绑定到特定设备
- 账号状态：记录账号登录状态、cookie有效性
- 多账号支持：一个设备可以管理多个账号

#### 数据模型
```python
账号表 (accounts)
- id: 主键，自增
- device_id: 关联设备ID
- account_name: 账号名称/标识
- platform: 平台类型 (douyin/tiktok/等)
- cookie_file_path: Cookie文件路径
- login_status: 登录状态 (logged_in/logged_out/expired)
- last_login_time: 最后登录时间
- created_at: 创建时间
- updated_at: 更新时间
```

#### API接口
- `POST /api/accounts` - 创建账号绑定
- `GET /api/accounts` - 获取账号列表（支持device_id过滤）
- `GET /api/accounts/{account_id}` - 获取账号详情
- `PUT /api/accounts/{account_id}/status` - 更新账号状态

### 3. 登录功能模块

#### 功能描述
- 远程触发登录：中心平台下发登录任务到设备
- 登录状态同步：设备执行登录后上报状态
- 登录任务队列：支持批量登录任务

#### 数据模型
```python
登录任务表 (login_tasks)
- id: 主键，自增
- account_id: 关联账号ID
- device_id: 关联设备ID
- status: 任务状态 (pending/running/success/failed)
- error_message: 错误信息（如果失败）
- created_at: 创建时间
- started_at: 开始执行时间
- completed_at: 完成时间
```

#### API接口
- `POST /api/login/trigger` - 触发登录任务
  - 请求体: `{"account_id": 1, "device_id": "xxx"}`
- `GET /api/login/tasks` - 获取登录任务列表
- `GET /api/login/tasks/{task_id}` - 获取任务详情
- `POST /api/login/callback` - 设备回调（上报登录结果）
  - 请求体: `{"task_id": 1, "status": "success", "cookie_file": "path/to/cookie.json"}`

### 4. 视频上传模块

#### 功能描述
- 视频任务下发：中心平台下发视频上传任务
- 视频信息传递：标题、标签、发布时间等元数据
- 视频文件传递：通过URL或文件上传方式传递视频文件
- 上传状态跟踪：实时跟踪上传进度和状态

#### 数据模型
```python
视频任务表 (video_tasks)
- id: 主键，自增
- account_id: 关联账号ID
- device_id: 关联设备ID
- video_url: 视频文件URL或本地路径
- video_title: 视频标题
- video_tags: 视频标签（JSON数组）
- publish_date: 发布时间（可选，0表示立即发布）
- thumbnail_url: 封面图URL（可选）
- status: 任务状态 (pending/uploading/success/failed)
- progress: 上传进度 (0-100)
- error_message: 错误信息
- created_at: 创建时间
- started_at: 开始执行时间
- completed_at: 完成时间
```

#### API接口
- `POST /api/video/upload` - 创建视频上传任务
  - 请求体: 
    ```json
    {
      "account_id": 1,
      "device_id": "xxx",
      "video_url": "http://server.com/videos/1.mp4",
      "video_title": "视频标题",
      "video_tags": ["标签1", "标签2"],
      "publish_date": "2025-01-20 10:00:00",
      "thumbnail_url": "http://server.com/thumbnails/1.png"
    }
    ```
- `GET /api/video/tasks` - 获取视频任务列表
- `GET /api/video/tasks/{task_id}` - 获取任务详情
- `POST /api/video/callback` - 设备回调（上报上传结果）
  - 请求体: `{"task_id": 1, "status": "success", "progress": 100}`

### 5. 对话功能模块

#### 功能描述
- 对话任务下发：中心平台下发对话发送任务
- 对话信息传递：目标用户名、消息内容
- 对话状态跟踪：跟踪消息发送状态

#### 数据模型
```python
对话任务表 (chat_tasks)
- id: 主键，自增
- account_id: 关联账号ID
- device_id: 关联设备ID
- target_user: 目标用户名
- message: 消息内容
- status: 任务状态 (pending/sending/success/failed)
- error_message: 错误信息
- created_at: 创建时间
- started_at: 开始执行时间
- completed_at: 完成时间
```

#### API接口
- `POST /api/chat/send` - 创建对话发送任务
  - 请求体: 
    ```json
    {
      "account_id": 1,
      "device_id": "xxx",
      "target_user": "用户名",
      "message": "消息内容"
    }
    ```
- `GET /api/chat/tasks` - 获取对话任务列表
- `GET /api/chat/tasks/{task_id}` - 获取任务详情
- `POST /api/chat/callback` - 设备回调（上报发送结果）
  - 请求体: `{"task_id": 1, "status": "success"}`

## 数据库设计

### SQLite数据库结构

```sql
-- 设备表
CREATE TABLE devices (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    device_id TEXT UNIQUE NOT NULL,
    device_name TEXT,
    ip_address TEXT,
    status TEXT DEFAULT 'offline',
    last_heartbeat DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 账号表
CREATE TABLE accounts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    device_id INTEGER NOT NULL,
    account_name TEXT NOT NULL,
    platform TEXT DEFAULT 'douyin',
    cookie_file_path TEXT,
    login_status TEXT DEFAULT 'logged_out',
    last_login_time DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (device_id) REFERENCES devices(id)
);

-- 登录任务表
CREATE TABLE login_tasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    account_id INTEGER NOT NULL,
    device_id INTEGER NOT NULL,
    status TEXT DEFAULT 'pending',
    error_message TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    started_at DATETIME,
    completed_at DATETIME,
    FOREIGN KEY (account_id) REFERENCES accounts(id),
    FOREIGN KEY (device_id) REFERENCES devices(id)
);

-- 视频任务表
CREATE TABLE video_tasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    account_id INTEGER NOT NULL,
    device_id INTEGER NOT NULL,
    video_url TEXT NOT NULL,
    video_title TEXT,
    video_tags TEXT,  -- JSON格式存储
    publish_date DATETIME,
    thumbnail_url TEXT,
    status TEXT DEFAULT 'pending',
    progress INTEGER DEFAULT 0,
    error_message TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    started_at DATETIME,
    completed_at DATETIME,
    FOREIGN KEY (account_id) REFERENCES accounts(id),
    FOREIGN KEY (device_id) REFERENCES devices(id)
);

-- 对话任务表
CREATE TABLE chat_tasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    account_id INTEGER NOT NULL,
    device_id INTEGER NOT NULL,
    target_user TEXT NOT NULL,
    message TEXT NOT NULL,
    status TEXT DEFAULT 'pending',
    error_message TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    started_at DATETIME,
    completed_at DATETIME,
    FOREIGN KEY (account_id) REFERENCES accounts(id),
    FOREIGN KEY (device_id) REFERENCES devices(id)
);
```

## API实现规范

### Flask应用结构

```
api_server/
├── __init__.py
├── app.py              # Flask应用主文件
├── models.py           # 数据库模型
├── routes/
│   ├── __init__.py
│   ├── devices.py      # 设备管理路由
│   ├── accounts.py     # 账号管理路由
│   ├── login.py        # 登录功能路由
│   ├── video.py        # 视频上传路由
│   └── chat.py         # 对话功能路由
└── utils/
    ├── __init__.py
    ├── database.py     # 数据库工具
    └── response.py     # 统一响应格式
```

### 统一响应格式

```python
# 成功响应
{
    "code": 200,
    "message": "success",
    "data": {...}
}

# 错误响应
{
    "code": 400,
    "message": "error message",
    "data": null
}
```

### 错误码定义

- `200`: 成功
- `400`: 请求参数错误
- `404`: 资源不存在
- `500`: 服务器内部错误

## 设备端Agent实现

### Agent职责

设备端需要实现一个轻量级的Agent程序，负责：
1. 定期向中心平台发送心跳
2. 轮询获取分配给本设备的任务
3. 执行任务（登录/上传/对话）
4. 上报任务执行结果

### Agent工作流程

```
1. 启动时注册设备到中心平台
2. 每30秒发送一次心跳
3. 每10秒轮询一次任务列表
4. 获取到任务后：
   - 更新任务状态为running
   - 调用对应的功能模块执行任务
   - 执行完成后调用回调API上报结果
```

### Agent API调用示例

```python
# 1. 设备注册
POST /api/devices/register
{
    "device_id": "device_001",
    "device_name": "设备1",
    "ip_address": "192.168.1.100"
}

# 2. 心跳
POST /api/devices/{device_id}/heartbeat

# 3. 获取任务
GET /api/tasks/pending?device_id={device_id}

# 4. 更新任务状态
PUT /api/tasks/{task_id}/status
{
    "status": "running"
}

# 5. 上报任务结果
POST /api/{task_type}/callback
{
    "task_id": 1,
    "status": "success",
    "data": {...}
}
```

## 文件传输方案

### 方案1：URL下载（推荐）

- 中心平台提供视频文件下载URL
- 设备Agent下载视频到本地临时目录
- 执行上传任务
- 任务完成后删除临时文件

### 方案2：直接文件上传

- 设备Agent通过HTTP POST上传文件到中心平台
- 中心平台存储文件并提供下载URL
- 适用于小文件或内网环境

### 方案3：共享存储

- 使用NFS/SMB等共享存储
- 中心平台将文件写入共享目录
- 设备Agent直接从共享目录读取
- 适用于局域网环境

## 安全考虑

### 1. 设备认证

- 设备注册时生成唯一token
- 后续请求携带token进行认证
- 使用JWT或简单的API Key机制

### 2. 数据加密

- 敏感信息（如cookie路径）在传输时加密
- 使用HTTPS协议（生产环境）

### 3. 访问控制

- 实现简单的权限控制
- 不同设备只能访问自己的任务

## 部署方案

### 中心平台部署

```bash
# 1. 安装依赖（项目已有requirements.txt）
pip install -r requirements.txt

# 2. 初始化数据库
python init_db.py

# 3. 启动Flask服务
python api_server/app.py
```

### 设备Agent部署

```bash
# 在每个设备上部署Agent程序
# Agent需要配置中心平台地址
# 例如：API_SERVER_URL=http://192.168.1.1:5000
```

## 扩展性考虑

### 1. 任务队列

如果任务量大，可以引入简单的任务队列：
- 使用Redis作为任务队列（可选）
- 或使用数据库表作为任务队列（简单方案）

### 2. 负载均衡

- 多个设备可以分担任务负载
- 根据设备状态和负载分配任务

### 3. 监控和日志

- 记录所有API请求日志
- 提供任务执行统计接口
- 异常告警机制

## 实现优先级

### Phase 1: 基础功能
1. 设备注册和心跳
2. 账号管理
3. 登录任务触发和回调

### Phase 2: 核心功能
1. 视频上传任务
2. 对话发送任务
3. 任务状态跟踪

### Phase 3: 优化功能
1. 文件传输优化
2. 任务队列和负载均衡
3. 监控和统计

## 注意事项

1. **轻量级原则**: 所有实现都遵循简单轻量的原则，避免引入复杂的中间件
2. **向后兼容**: 保持与现有功能模块的兼容性，通过适配器模式集成
3. **错误处理**: 完善的错误处理和重试机制
4. **日志记录**: 详细记录所有操作，便于问题排查
5. **数据备份**: 定期备份SQLite数据库

## 关键代码结构示例

### Flask应用主文件 (app.py)

```python
from flask import Flask
from flask_cors import CORS
from routes.devices import devices_bp
from routes.accounts import accounts_bp
from routes.login import login_bp
from routes.video import video_bp
from routes.chat import chat_bp
from utils.database import init_db

app = Flask(__name__)
CORS(app)  # 允许跨域请求

# 注册蓝图
app.register_blueprint(devices_bp, url_prefix='/api/devices')
app.register_blueprint(accounts_bp, url_prefix='/api/accounts')
app.register_blueprint(login_bp, url_prefix='/api/login')
app.register_blueprint(video_bp, url_prefix='/api/video')
app.register_blueprint(chat_bp, url_prefix='/api/chat')

# 初始化数据库
init_db()

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
```

### 数据库模型示例 (models.py)

```python
import sqlite3
from datetime import datetime
from typing import Optional

class Database:
    def __init__(self, db_path='data/center_platform.db'):
        self.db_path = db_path
        self.conn = None
    
    def get_connection(self):
        if self.conn is None:
            self.conn = sqlite3.connect(self.db_path)
            self.conn.row_factory = sqlite3.Row
        return self.conn
    
    def execute(self, query, params=()):
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute(query, params)
        conn.commit()
        return cursor
    
    def fetch_one(self, query, params=()):
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute(query, params)
        return cursor.fetchone()
    
    def fetch_all(self, query, params=()):
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute(query, params)
        return cursor.fetchall()
```

### 路由示例 (routes/login.py)

```python
from flask import Blueprint, request, jsonify
from utils.database import Database
from utils.response import success_response, error_response

login_bp = Blueprint('login', __name__)
db = Database()

@login_bp.route('/trigger', methods=['POST'])
def trigger_login():
    """触发登录任务"""
    data = request.json
    account_id = data.get('account_id')
    device_id = data.get('device_id')
    
    # 验证参数
    if not account_id or not device_id:
        return error_response(400, "缺少必要参数")
    
    # 创建登录任务
    query = """
        INSERT INTO login_tasks (account_id, device_id, status)
        VALUES (?, ?, 'pending')
    """
    cursor = db.execute(query, (account_id, device_id))
    task_id = cursor.lastrowid
    
    return success_response({"task_id": task_id})

@login_bp.route('/callback', methods=['POST'])
def login_callback():
    """设备回调，上报登录结果"""
    data = request.json
    task_id = data.get('task_id')
    status = data.get('status')
    
    # 更新任务状态
    if status == 'success':
        query = """
            UPDATE login_tasks 
            SET status = 'success', completed_at = CURRENT_TIMESTAMP
            WHERE id = ?
        """
    else:
        error_msg = data.get('error_message', '')
        query = """
            UPDATE login_tasks 
            SET status = 'failed', error_message = ?, completed_at = CURRENT_TIMESTAMP
            WHERE id = ?
        """
        db.execute(query, (error_msg, task_id))
    
    return success_response({"message": "回调成功"})
```

### 设备Agent示例结构

```python
import requests
import asyncio
import time
from pathlib import Path
from uploader.douyin_uploader.main import douyin_setup, DouYinVideo
from listener.douyin_listener.main import douyin_chat_main

class DeviceAgent:
    def __init__(self, api_server_url, device_id, device_name):
        self.api_server_url = api_server_url
        self.device_id = device_id
        self.device_name = device_name
        self.running = True
    
    def register_device(self):
        """注册设备到中心平台"""
        url = f"{self.api_server_url}/api/devices/register"
        data = {
            "device_id": self.device_id,
            "device_name": self.device_name,
            "ip_address": self.get_local_ip()
        }
        response = requests.post(url, json=data)
        return response.json()
    
    def send_heartbeat(self):
        """发送心跳"""
        url = f"{self.api_server_url}/api/devices/{self.device_id}/heartbeat"
        requests.post(url)
    
    def get_pending_tasks(self):
        """获取待处理任务"""
        url = f"{self.api_server_url}/api/tasks/pending"
        params = {"device_id": self.device_id}
        response = requests.get(url, params=params)
        return response.json().get('data', [])
    
    async def execute_login_task(self, task):
        """执行登录任务"""
        account_id = task['account_id']
        # 调用现有的登录功能
        account_file = self.get_account_file(account_id)
        result = await douyin_setup(account_file, handle=True)
        # 上报结果
        self.report_task_result('login', task['id'], 'success' if result else 'failed')
    
    async def execute_video_task(self, task):
        """执行视频上传任务"""
        # 下载视频文件
        video_path = self.download_video(task['video_url'])
        # 调用现有的上传功能
        video_obj = DouYinVideo(
            title=task['video_title'],
            file_path=video_path,
            tags=task['video_tags'],
            publish_date=task.get('publish_date', 0),
            account_file=self.get_account_file(task['account_id'])
        )
        await video_obj.main()
        # 上报结果
        self.report_task_result('video', task['id'], 'success')
    
    async def execute_chat_task(self, task):
        """执行对话任务"""
        # 写入chat.txt
        chat_file = Path("chat.txt")
        chat_file.write_text(f"{task['target_user']}\n{task['message']}")
        # 调用现有的对话功能
        account_file = self.get_account_file(task['account_id'])
        await douyin_chat_main(account_file)
        # 上报结果
        self.report_task_result('chat', task['id'], 'success')
    
    async def main_loop(self):
        """主循环"""
        # 注册设备
        self.register_device()
        
        while self.running:
            # 发送心跳
            self.send_heartbeat()
            
            # 获取任务
            tasks = self.get_pending_tasks()
            for task in tasks:
                task_type = task['type']
                if task_type == 'login':
                    await self.execute_login_task(task)
                elif task_type == 'video':
                    await self.execute_video_task(task)
                elif task_type == 'chat':
                    await self.execute_chat_task(task)
            
            await asyncio.sleep(10)  # 每10秒轮询一次

if __name__ == '__main__':
    agent = DeviceAgent(
        api_server_url="http://192.168.1.1:5000",
        device_id="device_001",
        device_name="设备1"
    )
    asyncio.run(agent.main_loop())
```

### 与现有代码集成要点

1. **登录功能集成**
   - 使用现有的 `douyin_setup()` 和 `douyin_cookie_gen()` 函数
   - Cookie文件路径从数据库的accounts表获取

2. **视频上传功能集成**
   - 使用现有的 `DouYinVideo` 类
   - 视频文件通过URL下载或共享存储获取
   - 视频元数据（标题、标签）从API请求中获取

3. **对话功能集成**
   - 使用现有的 `douyin_chat_main()` 函数
   - 对话信息（用户名、消息）从API请求中获取，写入chat.txt
   - 或者直接修改 `douyin_chat_main()` 函数，支持参数传递

## 总结

本方案提供了一个轻量级、易实现、易维护的中心管理平台架构。通过Flask + SQLite的组合，无需引入复杂的中间件，即可实现多设备管理、任务分发和状态同步的核心功能。整个系统设计简单直接，便于快速开发和部署。

### 实现检查清单

#### Phase 1: 基础框架
- [ ] 创建Flask应用主文件 (app.py)
- [ ] 创建数据库工具类 (utils/database.py)
- [ ] 创建统一响应格式工具 (utils/response.py)
- [ ] 实现数据库初始化脚本 (init_db.py)
- [ ] 创建数据库表结构（devices, accounts, login_tasks, video_tasks, chat_tasks）

#### Phase 2: 设备管理
- [ ] 实现设备注册API (POST /api/devices/register)
- [ ] 实现设备列表API (GET /api/devices)
- [ ] 实现设备详情API (GET /api/devices/{device_id})
- [ ] 实现设备心跳API (POST /api/devices/{device_id}/heartbeat)
- [ ] 实现设备状态自动更新（心跳超时检测）

#### Phase 3: 账号管理
- [ ] 实现账号创建API (POST /api/accounts)
- [ ] 实现账号列表API (GET /api/accounts)
- [ ] 实现账号详情API (GET /api/accounts/{account_id})
- [ ] 实现账号状态更新API (PUT /api/accounts/{account_id}/status)

#### Phase 4: 登录功能
- [ ] 实现登录任务创建API (POST /api/login/trigger)
- [ ] 实现登录任务列表API (GET /api/login/tasks)
- [ ] 实现登录任务详情API (GET /api/login/tasks/{task_id})
- [ ] 实现登录回调API (POST /api/login/callback)
- [ ] 集成现有登录功能模块

#### Phase 5: 视频上传功能
- [ ] 实现视频任务创建API (POST /api/video/upload)
- [ ] 实现视频任务列表API (GET /api/video/tasks)
- [ ] 实现视频任务详情API (GET /api/video/tasks/{task_id})
- [ ] 实现视频回调API (POST /api/video/callback)
- [ ] 实现视频文件下载功能
- [ ] 集成现有视频上传功能模块

#### Phase 6: 对话功能
- [ ] 实现对话任务创建API (POST /api/chat/send)
- [ ] 实现对话任务列表API (GET /api/chat/tasks)
- [ ] 实现对话任务详情API (GET /api/chat/tasks/{task_id})
- [ ] 实现对话回调API (POST /api/chat/callback)
- [ ] 集成现有对话功能模块

#### Phase 7: 设备Agent
- [ ] 创建设备Agent主程序
- [ ] 实现设备注册功能
- [ ] 实现心跳发送功能
- [ ] 实现任务轮询功能
- [ ] 实现任务执行功能（登录/上传/对话）
- [ ] 实现任务结果上报功能

#### Phase 8: 测试和优化
- [ ] 单元测试所有API接口
- [ ] 集成测试完整流程
- [ ] 性能测试和优化
- [ ] 错误处理和异常情况测试
- [ ] 文档完善

### 实现建议

1. **分阶段实现**: 先实现设备注册和心跳，再实现任务分发，最后完善所有功能
2. **保持简单**: 优先使用数据库表作为任务队列，避免引入Redis等中间件
3. **充分测试**: 每个模块完成后进行充分测试，确保与现有功能模块的兼容性
4. **文档同步**: 实现过程中及时更新API文档和数据库结构说明
5. **代码复用**: 充分利用现有的功能模块，通过适配器模式集成，避免重复开发

